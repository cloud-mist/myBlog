[{"categories":["Markdown"],"content":"Guide to emoji usage in Hugo and LoveIt.","date":"2019-10-01","objectID":"/programming/hello/","tags":["emoji"],"title":"Emoji Support","uri":"/programming/hello/"},{"categories":["Markdown"],"content":"Emoji can be enabled in a Hugo project in a number of ways. The emojify function can be called directly in templates or Inline Shortcodes. To enable emoji globally, set enableEmoji to true in your site configuration and then you can type emoji shorthand codes directly in content files. These begin and end with a colon and include the code of an emoji: Gone camping! :tent: Be back soon. That is so funny! :joy: The rendered output looks like this: Gone camping! :tent: Be back soon. That is so funny! :joy: The following cheat sheet is a useful reference for emoji shorthand codes. ","date":"2019-10-01","objectID":"/programming/hello/:0:0","tags":["emoji"],"title":"Emoji Support","uri":"/programming/hello/"},{"categories":["算法"],"content":"栈 ","date":"2022-04-11","objectID":"/programming/alg-struct-stkque/:1:0","tags":["栈","队列","排序"],"title":"Alg | 栈/队列/排序","uri":"/programming/alg-struct-stkque/"},{"categories":["算法"],"content":"1. 包含Min函数的栈 问题 栈支持 $O(1)$ 入栈和出栈, 但不支持查询最小值 想法 直接：维护一个小顶堆 $O(logN)$ 启示：用一个变量维护最小值，但如果最小值出栈后就不知道了 -\u003e 维护一个栈,来保存每时刻最小值 做法 建立两个栈，栈A存储原数据，栈B存储以栈底开头的每段数据的最小值 Push时，A中插入x, B中插入 $min(B栈顶，x)$; Pop时，A,B都需弹出栈顶; GetMin时，输出B的栈顶 Code var stk1,stk2 []int func Push(x int) { stk1 = append(stk1, x) if len(stk2)==0{ stk2 = append(stk2, x) }else{ tmp := min(stk2[len(stk2)-1], x) stk2 = append(stk2, tmp) } } func Pop() { stk1 = stk1[:len(stk1)-1] stk2 = stk2[:len(stk2)-1] } func Top() int { return stk1[len(stk1)-1] } func Min() int { return stk2[len(stk2)-1] } func min(x, y int) int{ if x\u003ey{ return y } return x } ","date":"2022-04-11","objectID":"/programming/alg-struct-stkque/:1:1","tags":["栈","队列","排序"],"title":"Alg | 栈/队列/排序","uri":"/programming/alg-struct-stkque/"},{"categories":["算法"],"content":"排序 ","date":"2022-04-11","objectID":"/programming/alg-struct-stkque/:2:0","tags":["栈","队列","排序"],"title":"Alg | 栈/队列/排序","uri":"/programming/alg-struct-stkque/"},{"categories":["算法"],"content":"1. 第K大 问题 找出第K大的数 / 找出倒数第K大的 （同一类问题） 想法 使用快排的思想 $O(nlogn)$ 快排一轮 -\u003e 基准点左边比他大，右边比他小。 或者相反。 实现 选取基准，将大的放到基准左边，小的放到右边 统计 大于基准的数的个数cnt 若 $k\u003c=cnt$,说明答案在左边，递归 若 $k\u003ecnt$,说明答案在右边，递归 Code func findKth(q []int, n int, k int) int { return qsort(0, n-1, k, q) } func qsort(l, r, k int, q []int) int { if l == r { return q[l] } x := q[(l+r)\u003e\u003e1] i, j := l-1, r+1 for i \u003c j { for { i++ if q[i] \u003c= x { break } } for { j-- if q[j] \u003e= x { break } } if i \u003c j { q[i], q[j] = q[j], q[i] } } sl := j - l + 1 if k \u003c= sl { return qsort(l, j, k, q) } return qsort(j+1, r, k-sl, q) } ","date":"2022-04-11","objectID":"/programming/alg-struct-stkque/:2:1","tags":["栈","队列","排序"],"title":"Alg | 栈/队列/排序","uri":"/programming/alg-struct-stkque/"},{"categories":["算法"],"content":"判定质数-\u003e试除法 ","date":"2022-03-04","objectID":"/programming/alg-math-prime/:0:0","tags":["质数","素数"],"title":"Alg | 质数","uri":"/programming/alg-math-prime/"},{"categories":["算法"],"content":"备注 质数定义 质数是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。 朴素 -\u003eO(n) 小于2的数都不是质数 如果2-n中的数能把n整除，说明不是质数 优化 -\u003eO(sqrt(n)) 因数是成对出现的，若 d|n ,则有 n/d | n. 所以 d\u003c=n/d ==\u003e d**2\u003c=n ==\u003e d\u003c=sqrt(n) ","date":"2022-03-04","objectID":"/programming/alg-math-prime/:1:0","tags":["质数","素数"],"title":"Alg | 质数","uri":"/programming/alg-math-prime/"},{"categories":["算法"],"content":"Code func isPrime(n int) bool { if n \u003c 2 { return false } for i := 2; i \u003c= n/i; i++ { if n%i == 0 { return false } } return true } 质因数分解 ","date":"2022-03-04","objectID":"/programming/alg-math-prime/:2:0","tags":["质数","素数"],"title":"Alg | 质数","uri":"/programming/alg-math-prime/"},{"categories":["算法"],"content":"备注 ","date":"2022-03-04","objectID":"/programming/alg-math-prime/:3:0","tags":["质数","素数"],"title":"Alg | 质数","uri":"/programming/alg-math-prime/"},{"categories":["算法"],"content":"Code func divide(n int) { for i := 2; i \u003c= n/i; i++ { if n%i == 0 { s := 0 for n%i == 0 { n /= i s++ } fmt.Printf(\"%d %d\\n\", i, s) } } if n \u003e 1 { fmt.Printf(\"%d %d\\n\", n, 1) } } ","date":"2022-03-04","objectID":"/programming/alg-math-prime/:4:0","tags":["质数","素数"],"title":"Alg | 质数","uri":"/programming/alg-math-prime/"},{"categories":["年度小唠"],"content":" 突然间，已经记不清 7 月之前我做了什么，我在哪里。噢，只不过是上了一些乱七八糟的课罢了，应付着那些无聊的考试。 时间的流逝真的是飞快，仿佛我还停留在 2008 年的奥运之年，春晚定时收看，炮定时放。过年时还要跋山涉水，物质也并不富足相比此时，但当时是如此的快乐，也许那时只属于孩子的快乐吧。扯的有点远，那么今年做了什么东西呢。 ","date":"2021-12-31","objectID":"/life/talk-end2021/:0:0","tags":["总结","闲谈"],"title":"2021 回味与小唠","uri":"/life/talk-end2021/"},{"categories":["年度小唠"],"content":"娱乐方面  真的是看了不少很好的电影，还有很值得一玩的游戏。 Films Jai Bhim CODA Finch Free Guy 沙丘 扬名立万 Games  银河恶魔城游戏，很有挑战性，但这三个可谓是第九艺术。美术和音乐真的很棒。 Ori 与黑暗森林(15h) Ori 与萤火意志(15h) Hollow Knight(55h) Music  还是听着梁博的，朴树的，李健的。多了 YOASOBI. 指弹只看了 MISKO 的三首合作，真的很棒。吉他水平越来越差，也许这蒙尘的吉他再放就要放坏了吧。 ","date":"2021-12-31","objectID":"/life/talk-end2021/:0:1","tags":["总结","闲谈"],"title":"2021 回味与小唠","uri":"/life/talk-end2021/"},{"categories":["年度小唠"],"content":"一些产品 IQUNIX OG80 XBOX 手柄 ","date":"2021-12-31","objectID":"/life/talk-end2021/:0:2","tags":["总结","闲谈"],"title":"2021 回味与小唠","uri":"/life/talk-end2021/"},{"categories":["年度小唠"],"content":"学习方面  学了很久的算法，还是不见长进，ccf 继续 170,，真的很菜。要继续看密码学了，搞一下研究吧。还在学 Haskell,欣赏一下 Pure 函数式语言的魅力。Golang 还算学的还行吧，但是实际应用的小项目还没有实践过,明年 2 月左右就可以加入泛型，还挺激动的。还想使用一下FreeBSD,体验个小半年试试。论文啊，还在催。 ","date":"2021-12-31","objectID":"/life/talk-end2021/:0:3","tags":["总结","闲谈"],"title":"2021 回味与小唠","uri":"/life/talk-end2021/"},{"categories":["年度小唠"],"content":"总结  总之，学习方面不尽如人意，无论是基础的，还是科研方面的。加油吧。混沌着迷茫着，我坠入的世界的深渊，但不知该飘向何方。 哪有所谓的自由之处，哪里都是江湖。 忆の风 2021.12.31 ","date":"2021-12-31","objectID":"/life/talk-end2021/:0:4","tags":["总结","闲谈"],"title":"2021 回味与小唠","uri":"/life/talk-end2021/"},{"categories":"Golang","content":"分享一下go的IO在算法题中的使用，提升效率","date":"2021-10-22","objectID":"/programming/go-alg-io/","tags":["算法","go","IO","输入输出","bufio"],"title":"Golang | 算法题的输入输出","uri":"/programming/go-alg-io/"},{"categories":"Golang","content":"「前言」 本篇分享介绍 3 个版本，层层递进 接下来以 Acwing796.子矩阵的和 为例 ","date":"2021-10-22","objectID":"/programming/go-alg-io/:1:0","tags":["算法","go","IO","输入输出","bufio"],"title":"Golang | 算法题的输入输出","uri":"/programming/go-alg-io/"},{"categories":"Golang","content":"「题目」 题目：输入一个 $n$ 行 $m$ 列的整数矩阵，再输入 $q$ 个询问，每个询问包含四个整数 $x_1,y_1,x_2,y_2$，表示一个子矩阵的左上角坐标和右下角坐标。对于每个询问输出子矩阵中所有数的和。 输入：第一行包含三个整数 $n，m，q$。 接下来 $n$ 行，每行包含 $m$ 个整数，表示整数矩阵。 接下来 $q$ 行，每行包含四个整数 $x_1,y_1,x_2,y_2$，表示一组询问。 输出：共 $q$ 行，每行输出一个询问的结果。 ","date":"2021-10-22","objectID":"/programming/go-alg-io/:2:0","tags":["算法","go","IO","输入输出","bufio"],"title":"Golang | 算法题的输入输出","uri":"/programming/go-alg-io/"},{"categories":"Golang","content":"「Ver. 1」 ","date":"2021-10-22","objectID":"/programming/go-alg-io/:3:0","tags":["算法","go","IO","输入输出","bufio"],"title":"Golang | 算法题的输入输出","uri":"/programming/go-alg-io/"},{"categories":"Golang","content":"Use\u0026Result fmt.Scan() 和 fmt.Print()系列 Res：..TLE.. ","date":"2021-10-22","objectID":"/programming/go-alg-io/:3:1","tags":["算法","go","IO","输入输出","bufio"],"title":"Golang | 算法题的输入输出","uri":"/programming/go-alg-io/"},{"categories":"Golang","content":"Code package main import ( \"fmt\" ) const N = 1010 func main() { var n, m, q int fmt.Scan(\u0026n, \u0026m, \u0026q) a := make([][N]int, N) for i := 1; i \u003c= n; i++ { for j := 1; j \u003c= m; j++ { fmt.Scan(\u0026a[i][j]) a[i][j] += a[i-1][j] + a[i][j-1] - a[i-1][j-1] } } var x1, y1, x2, y2 int for ; q != 0; q-- { fmt.Scan(\u0026x1, \u0026y1, \u0026x2, \u0026y2) res := a[x2][y2] - a[x1-1][y2] - a[x2][y1-1] + a[x1-1][y1-1] fmt.Println(res) } } ","date":"2021-10-22","objectID":"/programming/go-alg-io/:3:2","tags":["算法","go","IO","输入输出","bufio"],"title":"Golang | 算法题的输入输出","uri":"/programming/go-alg-io/"},{"categories":"Golang","content":"「Ver. 2」 ","date":"2021-10-22","objectID":"/programming/go-alg-io/:4:0","tags":["算法","go","IO","输入输出","bufio"],"title":"Golang | 算法题的输入输出","uri":"/programming/go-alg-io/"},{"categories":"Golang","content":"Use\u0026Result bufio.NewWriter \u0026 bufio.NewReader 配套的 Fscan\u0026Fprint 系列 Res：4296ms ","date":"2021-10-22","objectID":"/programming/go-alg-io/:4:1","tags":["算法","go","IO","输入输出","bufio"],"title":"Golang | 算法题的输入输出","uri":"/programming/go-alg-io/"},{"categories":"Golang","content":"Code package main import ( \"bufio\" \"fmt\" \"os\" ) const N = 1010 func main() { defer ot.Flush() var n, m, q int fmt.Fscan(in, \u0026n, \u0026m, \u0026q) a := make([][N]int, N) for i := 1; i \u003c= n; i++ { for j := 1; j \u003c= m; j++ { fmt.Fscan(in, \u0026a[i][j]) a[i][j] += a[i-1][j] + a[i][j-1] - a[i-1][j-1] } } var x1, y1, x2, y2 int for ; q != 0; q-- { fmt.Fscan(in, \u0026x1, \u0026y1, \u0026x2, \u0026y2) res := a[x2][y2] - a[x1-1][y2] - a[x2][y1-1] + a[x1-1][y1-1] fmt.Fprintln(ot, res) } } const BUFSIZE = int(1e6) var ( ot = bufio.NewWriterSize(os.Stdout, BUFSIZE) in = bufio.NewReader(os.Stdin) ) ","date":"2021-10-22","objectID":"/programming/go-alg-io/:4:2","tags":["算法","go","IO","输入输出","bufio"],"title":"Golang | 算法题的输入输出","uri":"/programming/go-alg-io/"},{"categories":"Golang","content":"「Ver. 3」 借鉴自 atcoder 的一位 大哥 ，我删减修改形成 ","date":"2021-10-22","objectID":"/programming/go-alg-io/:5:0","tags":["算法","go","IO","输入输出","bufio"],"title":"Golang | 算法题的输入输出","uri":"/programming/go-alg-io/"},{"categories":"Golang","content":"Use\u0026Result 使用bufio.NewScanner() 结果：仅仅..840ms.. ","date":"2021-10-22","objectID":"/programming/go-alg-io/:5:1","tags":["算法","go","IO","输入输出","bufio"],"title":"Golang | 算法题的输入输出","uri":"/programming/go-alg-io/"},{"categories":"Golang","content":"How to use rn 3 个函数，是读单个数字或字符串; rs 函数，是返回一个 slice. ","date":"2021-10-22","objectID":"/programming/go-alg-io/:5:2","tags":["算法","go","IO","输入输出","bufio"],"title":"Golang | 算法题的输入输出","uri":"/programming/go-alg-io/"},{"categories":"Golang","content":"Code package main import ( \"bufio\" \"fmt\" \"os\" \"strconv\" ) const N = 1010 func main() { defer ot.Flush() n, m, q := rnI(), rnI(), rnI() a := make([][N]int, N) for i := 1; i \u003c= n; i++ { for j := 1; j \u003c= m; j++ { a[i][j] = rnI() a[i][j] += a[i-1][j] + a[i][j-1] - a[i-1][j-1] } } for ; q != 0; q-- { x1, y1, x2, y2 := rnI(), rnI(), rnI(), rnI() res := a[x2][y2] - a[x1-1][y2] - a[x2][y1-1] + a[x1-1][y1-1] fmt.Fprintln(ot, res) } } /* ======================================================================== */ // // // // _____ _ _ ____ // | ____| | \\ | | | _ \\ // | _| | \\| | | | | | // | |___ | |\\ | | |_| | // |_____| |_| \\_| |____/ // // // /* ============================PART1: I/O ================================== */ var ( ot = bufio.NewWriterSize(os.Stdout, int(1e6)) in = bufio.NewScanner(os.Stdin) ) func init() { in.Split(bufio.ScanWords); in.Buffer(make([]byte, 4096), int(1e9)) } func rnS() string { in.Scan(); return in.Text() } func rnI() int { i, _ := strconv.Atoi(rnS()); return i } func rnF() float64 { f, _ := strconv.ParseFloat(rnS(), 64); return f } func rsI(l, r int) []int { t := make([]int, r) for i := l; i \u003c r; i++ { t[i] = rnI() } return t } ","date":"2021-10-22","objectID":"/programming/go-alg-io/:5:3","tags":["算法","go","IO","输入输出","bufio"],"title":"Golang | 算法题的输入输出","uri":"/programming/go-alg-io/"},{"categories":"蓝书の笔记","content":"前缀和与差分总结","date":"2021-07-23","objectID":"/programming/acg-0x03/","tags":["算法","前缀和","差分"],"title":"Acg | 0x03","uri":"/programming/acg-0x03/"},{"categories":"蓝书の笔记","content":"hello ","date":"2021-07-23","objectID":"/programming/acg-0x03/:0:0","tags":["算法","前缀和","差分"],"title":"Acg | 0x03","uri":"/programming/acg-0x03/"},{"categories":"蓝书の笔记","content":"壹、介绍 前缀和：$O(1)$求某个区间或区域的和 差分 ：$O(1)$为某个连续区间或区域加一个固定的值 ","date":"2021-07-23","objectID":"/programming/acg-0x03/:1:0","tags":["算法","前缀和","差分"],"title":"Acg | 0x03","uri":"/programming/acg-0x03/"},{"categories":"蓝书の笔记","content":"贰、模板 ","date":"2021-07-23","objectID":"/programming/acg-0x03/:2:0","tags":["算法","前缀和","差分"],"title":"Acg | 0x03","uri":"/programming/acg-0x03/"},{"categories":"蓝书の笔记","content":"「一维前缀和」 Analyse 求一段区间的和 $$sum(l,r) = b[r]-b[l-1]$$ code # input, 0位置存储0,从1开始存数 n,m=map(int, input().split()) a=[0] a.extend(list(map(int, input().split()))) b=[0]*(n+1) # 前缀和 for i in range(1,n+1): b[i] = b[i-1]+a[i] # output while m: m-=1 l,r=map(int, input().split()) print(b[r]-b[l-1]) ","date":"2021-07-23","objectID":"/programming/acg-0x03/:2:1","tags":["算法","前缀和","差分"],"title":"Acg | 0x03","uri":"/programming/acg-0x03/"},{"categories":"蓝书の笔记","content":"「二维前缀和」 Analyse code # input n,m,q=map(int,input().split()) a=[[0 for i in range(m+1)] for j in range(n+1)] b=[[0 for i in range(m+1)] for j in range(n+1)] for i in range(1,n+1): temp=list(map(int, input().split())) for j in range(m): a[i][j+1] = temp[j] # 前缀和 for i in range(1,n+1): for j in range(1,m+1): b[i][j] = b[i-1][j] + b[i][j-1] - b[i-1][j-1] + a[i][j] # output while q: q-=1 x1,y1,x2,y2=map(int, input().split()) print(b[x2][y2]-b[x1-1][y2]-b[x2][y1-1]+b[x1-1][y1-1]) ","date":"2021-07-23","objectID":"/programming/acg-0x03/:2:2","tags":["算法","前缀和","差分"],"title":"Acg | 0x03","uri":"/programming/acg-0x03/"},{"categories":"蓝书の笔记","content":"「一维差分」 Analyse 想让$[l,r]$区间的数$+c$,如果让$b[l]+c$,会使$b$的前缀和数组$l$位置后面的所有数都会$+c$, 所以问题来了，怎么能使$r$位置后面的数不加$c$呢？ $b[r+1]-c$即可。 code # 使a数组 [l,r]区间的数都加c def insert(l,r,c): b[l]+=c b[r+1]-=c # input n,m=map(int, input().split()) a=[0] a.extend(list(map(int, input().split()))) b=[0]*(n+10) # 用a构造b数组 for i in range(1,n+1): insert(i,i,a[i]) # op while m: m-=1 l,r,c=map(int, input().split()) insert(l,r,c) # 求b数组前缀和，得到操作完成之后的a数组 for i in range(1,n+1): b[i] += b[i-1] # output for i in range(1,n+1): print(b[i],end=' ') ","date":"2021-07-23","objectID":"/programming/acg-0x03/:2:3","tags":["算法","前缀和","差分"],"title":"Acg | 0x03","uri":"/programming/acg-0x03/"},{"categories":"蓝书の笔记","content":"「二维差分」 Analyse 同一维差分原理一致，从给某个区间变成给某个矩形区域加 c,只需推导公式即可. $$ \\begin{cases} b_{x_1,y_1}+=c, \\ b_{x_2+1,y_1}-=c, \\ b_{x1,y_2+1}-=c, \\ b_{x_2+1,y_2+1}+=c. \\ \\end{cases} $$ Code # 某个面积区域内加c def insert(x1,y1,x2,y2,c): b[x1][y1] += c b[x1][y2+1] -= c b[x2+1][y1] -= c b[x2+1][y2+1] += c # input n,m,q=map(int, input().split()) a=[[0 for i in range(m+2)] for j in range(n+2)] b=[[0 for i in range(m+2)] for j in range(n+2)] for i in range(1,n+1): temp=list(map(int, input().split())) for j in range(m): a[i][j+1] = temp[j] # b数组差分初始化 for i in range(1,n+1): for j in range(1,m+1): insert(i,j,i,j,a[i][j]) # op while q: q-=1 x1,y1,x2,y2,c=map(int, input().split()) insert(x1,y1,x2,y2,c) # 求前缀和 for i in range(1,n+1): for j in range(1,m+1): b[i][j] += b[i-1][j] + b[i][j-1] -b[i-1][j-1] # output for i in range(1,n+1): for j in range(1,m+1): print(b[i][j],end=' ') print() ","date":"2021-07-23","objectID":"/programming/acg-0x03/:2:4","tags":["算法","前缀和","差分"],"title":"Acg | 0x03","uri":"/programming/acg-0x03/"},{"categories":"蓝书の笔记","content":"叁、题目 ","date":"2021-07-23","objectID":"/programming/acg-0x03/:3:0","tags":["算法","前缀和","差分"],"title":"Acg | 0x03","uri":"/programming/acg-0x03/"},{"categories":"蓝书の笔记","content":"二分总结","date":"2021-07-22","objectID":"/programming/acg-0x04/","tags":["算法","二分"],"title":"Acg | 0x04","uri":"/programming/acg-0x04/"},{"categories":"蓝书の笔记","content":"一、整数二分 ","date":"2021-07-22","objectID":"/programming/acg-0x04/:1:0","tags":["算法","二分"],"title":"Acg | 0x04","uri":"/programming/acg-0x04/"},{"categories":"蓝书の笔记","content":"Explain 将模板分为二种情况,循环以l=r结束 看第一段，若$a[mid]\u003e=x$,因为是单增序列，推出 mid 后面的数会更大，所以缩小区间为左半段,又 mid 也可能是答案，因此r=mid 为什么采用右移运算，而不是除法。右移是向下取整，整除是向零取整，在值域包含负数的时候后者没法正常工作。 ","date":"2021-07-22","objectID":"/programming/acg-0x04/:1:1","tags":["算法","二分"],"title":"Acg | 0x04","uri":"/programming/acg-0x04/"},{"categories":"蓝书の笔记","content":"Code 在单增序列 a 中查找$\\geq{x}$中最小的那个 while l\u003cr: mid=l+r\u003e\u003e1 if a[mid]\u003e=x: r=mid else: l=mid+1 在 a 中找$\\leq{x}$中最大的那个 while l\u003cr: mid=l+r+1\u003e\u003e1 if a[mid]\u003c=x: l=mid else: r=mid-1 ","date":"2021-07-22","objectID":"/programming/acg-0x04/:1:2","tags":["算法","二分"],"title":"Acg | 0x04","uri":"/programming/acg-0x04/"},{"categories":"蓝书の笔记","content":"Problems E1 数的范围 topic 给定一个按照升序排列的长度为 n 的整数数组,以及 q 个查询。对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始计数）。如果数组中不存在该元素，则返回 -1 -1. analyse 先用模板找起始位置，即最小的那个。 如果s[l]!=x,说明没找到，输出-1 -1即可， 否则，输出起始，再用模板找终止位置即可。 code n,q=map(int, input().split()) s=list(map(int, input().split())) while q: q-=1 x=int(input()) l,r=0,n-1 while l\u003cr: mid =l+r\u003e\u003e1 if s[mid]\u003e=x: r=mid else: l=mid+1 if s[l]!=x: print('-1 -1') else: print(l,end=' ') l,r=0,n-1 while l\u003cr: mid=l+r+1\u003e\u003e1 if s[mid]\u003c=x: l=mid else: r=mid-1 print(l) ","date":"2021-07-22","objectID":"/programming/acg-0x04/:1:3","tags":["算法","二分"],"title":"Acg | 0x04","uri":"/programming/acg-0x04/"},{"categories":"蓝书の笔记","content":"二、实数二分 ","date":"2021-07-22","objectID":"/programming/acg-0x04/:2:0","tags":["算法","二分"],"title":"Acg | 0x04","uri":"/programming/acg-0x04/"},{"categories":"蓝书の笔记","content":"Explain 确定精度eps.如果需要保留 k 位小数，$eps=1e-(k+2)$ ","date":"2021-07-22","objectID":"/programming/acg-0x04/:2:1","tags":["算法","二分"],"title":"Acg | 0x04","uri":"/programming/acg-0x04/"},{"categories":"蓝书の笔记","content":"Code while l+1e-5\u003cr: mid=(l+r)/2 if calc(mid): r=mid else: l=mid ","date":"2021-07-22","objectID":"/programming/acg-0x04/:2:2","tags":["算法","二分"],"title":"Acg | 0x04","uri":"/programming/acg-0x04/"},{"categories":"蓝书の笔记","content":"Problems E1 数的三次方根 题目 给定一个浮点数 n，求它的三次方根。 code x=float(input()) N=1e4 l,r=-N,N while l+1e-8\u003cr: mid = (l+r)/2 if mid**3\u003e=x: r=mid else: l=mid print(\"%.6f\" % l) ","date":"2021-07-22","objectID":"/programming/acg-0x04/:2:3","tags":["算法","二分"],"title":"Acg | 0x04","uri":"/programming/acg-0x04/"},{"categories":"蓝书の笔记","content":"三、二分答案转换成判定 ","date":"2021-07-22","objectID":"/programming/acg-0x04/:3:0","tags":["算法","二分"],"title":"Acg | 0x04","uri":"/programming/acg-0x04/"},{"categories":"蓝书の笔记","content":"Explain 题目中出现类似于“最大值最小”的含义，这是答案具有单调性，可用二分转化成判定的特征之一 ","date":"2021-07-22","objectID":"/programming/acg-0x04/:3:1","tags":["算法","二分"],"title":"Acg | 0x04","uri":"/programming/acg-0x04/"},{"categories":"蓝书の笔记","content":"Problems E1 最佳牛围栏 思考 转换题目：给定正整数数列 A,求一个平均数最大且长度不小于 L 的连续子段. 如果 mid 是答案，判定“是否存在一个长度不小于 L 的子段，平均数不小于二分的值” 如果每个数都减去 mid,那么就转化为，“是否存在一个长度不小于 L 的子段，子段和\u003e=0” 如果存在，则更新l=mid,因为答案肯定在右边 code n,f=map(int, input().split()) cow=[0] sum=[0]\\*(n+1) for i in range(1,n+1): cow.append(int(input())) def check(mid): # 要逐次-mid for i in range(1,n+1): sum[i] = sum[i-1]+cow[i]-mid minv=0 # 因为sum[0]是0 i,j=0,f while j\u003c=n: minv = min(minv, sum[i]) #记录之前的最小值 if sum[j]-minv\u003e=0: # 说明有合法方案 return True j+=1;i+=1 return False l,r=0,2000 while l+1e-5\u003cr: mid=(l+r)/2 if check(mid): # 说明存在平均值不小于二分的值，所以要取右半边 l=mid else: r=mid print(int(r*1000)) ``` [E2 防线](https://www.acwing.com/problem/content/description/122/) 思考 code T = int(input()) while T: T-=1 s=[] n=int(input()) l,r=0,0 for i in range(n): ss,e,d=map(int, input().split()) s.append([ss,e,d]) r=max(r, e) def getsum(x): res=0 for i in s: if i[0]\u003c=x: res += (min(i[1], x) - i[0]) // i[2] + 1 return res while l\u003cr: mid = l+r\u003e\u003e1 if getsum(mid)%2: #如果是奇数,答案肯定在左半边 r=mid else: l=mid+1 sum = getsum(r)-getsum(r-1) if sum%2: print(r,sum) else: print(\"There's no weakness.\") ","date":"2021-07-22","objectID":"/programming/acg-0x04/:3:2","tags":["算法","二分"],"title":"Acg | 0x04","uri":"/programming/acg-0x04/"},{"categories":"Cube","content":"cfop公式之p","date":"2021-06-24","objectID":"/life/hb-cube-pll/","tags":["pll","cfop","魔方"],"title":"Cube | PLL","uri":"/life/hb-cube-pll/"},{"categories":"Cube","content":"PLL  记录一下我所使用和即将使用的pll ","date":"2021-06-24","objectID":"/life/hb-cube-pll/:1:0","tags":["pll","cfop","魔方"],"title":"Cube | PLL","uri":"/life/hb-cube-pll/"},{"categories":"Cube","content":"1. Alg Name Case Alg PB Ua RU'RU(RURU'R'U'R'2) 1.42s Ub L'UL'U'(L'U'L'ULUL'2) 1.28s Aa RUR'F'rUR'U'r'FR2U'R' 1.27s Ab (L'U'LF)(r'U'LU)rF'L2'UL 2.03s H M'2U' M'2U'2 M'2U' M'2 1.21s Z M'U'(M2U')2 M'U2M2 1.78s Na (RF) (U'R'URU) F'R2'F'RURU'R'F 2.10s Nb (L'F') (ULU'L'U') FL2FL'U'L'ULF' 2.21s Ja L'U'LFL'U'LU (LF'L'2 UL) 1.41s Jb RUR'F'RUR'U' (R'FR2U'R') 1.04s Ra (LU'2 L'U2) (LF' L'U'LU) LFL'2 1.89s Rb (R'U2 RU'2) (R'F RUR'U') R'F'R2 1.52s Ga R2U(R'UR'U') (RU'R2DU') R'URD' 1.84s Gb (F'U' FR2u) (R'URU'Ru'R2) 1.76s Gc (R2F2) (RU2RU2') (R'FRUR'U'R'FR2) 2.13s Gd (RUR'U'D) R2U'RU'R'UR' (UR2D) 1.93s E x' (RU'R'D RUR'D') (RUR'D RU'R'D')x 1.51s F (R'FRf')(R'FR2UR'U'R'F')(R2UR'S) 1.85s T RUR'U' R'FR2U'R'U' (RUR'F') 1.42s Y F RU'R'U' RUR'F' (RUR'U' R'FRF') 1.54s V (RU')(RUR'D) RD'RU'D R2'UR2D'R2' 1.96s ","date":"2021-06-24","objectID":"/life/hb-cube-pll/:1:1","tags":["pll","cfop","魔方"],"title":"Cube | PLL","uri":"/life/hb-cube-pll/"},{"categories":"Cube","content":"2. Others 后续应该会链接每个公式各up的b站手法视频 word download 若有任何问题都可以联系我😄 ","date":"2021-06-24","objectID":"/life/hb-cube-pll/:1:2","tags":["pll","cfop","魔方"],"title":"Cube | PLL","uri":"/life/hb-cube-pll/"},{"categories":"Blog","content":"一之diary篇","date":"2021-05-04","objectID":"/programming/blog-hugoanddiary/","tags":["theme","hugo","blog"],"title":"Blog搭建的那点小事","uri":"/programming/blog-hugoanddiary/"},{"categories":"Blog","content":"一、相识  原来是在Hexo平台，折腾Next主题,过了一段时间发现那并不是我想要的。 首先,hexo有点慢这是实话，所以早换晚换肯定要换，那就搜搜看，结果便找到了Hugo,由Golang开发而成,速度很快。 Okay,平台有了，那还得有个主题不是，找啊找找啊找，发现了Even，用了一段时间，还是觉得不太美观，但已经相当美观，而且功能很全，已经接近了我想要的东西。 于是乎，便又在Github上翻，发现了目前的主题Diary,界面已经很棒，功能还有待补全。 只得一声叹息，为什么我不会前端，why，也许最适合自己的是自己造一个。可惜不会，还不学，那有啥子办法呢？等时机成熟，等我学，便是一个新的主题的诞生。 诶，这主题换了不少，结果定睛一看,好家伙,博文几乎为0,这...🤣 ","date":"2021-05-04","objectID":"/programming/blog-hugoanddiary/:1:0","tags":["theme","hugo","blog"],"title":"Blog搭建的那点小事","uri":"/programming/blog-hugoanddiary/"},{"categories":"Blog","content":"二、安装 Hugo: 官方文档zh版 照链接安装即可。哈？那这篇文章存在的意义在哪里 Diary: 说明文档 ","date":"2021-05-04","objectID":"/programming/blog-hugoanddiary/:2:0","tags":["theme","hugo","blog"],"title":"Blog搭建的那点小事","uri":"/programming/blog-hugoanddiary/"},{"categories":"Blog","content":"三、简易配置 ","date":"2021-05-04","objectID":"/programming/blog-hugoanddiary/:3:0","tags":["theme","hugo","blog"],"title":"Blog搭建的那点小事","uri":"/programming/blog-hugoanddiary/"},{"categories":"Blog","content":"前期工作 把主题exampleSite文件夹里的config.toml copy到博客根目录 把archetypes里的default.md放到博客那个文件夹 照说明文档把config.toml改一下 ","date":"2021-05-04","objectID":"/programming/blog-hugoanddiary/:3:1","tags":["theme","hugo","blog"],"title":"Blog搭建的那点小事","uri":"/programming/blog-hugoanddiary/"},{"categories":"Blog","content":"About页 config.toml添加以下内容 [[menu.main]] url = \"/about/index.html\" name = \"關於\" weight = 4 # 位置摆放 在content文件夹下创建about.md即可 ","date":"2021-05-04","objectID":"/programming/blog-hugoanddiary/:3:2","tags":["theme","hugo","blog"],"title":"Blog搭建的那点小事","uri":"/programming/blog-hugoanddiary/"},{"categories":"Blog","content":"插入图片 先需要修改config.toml,在[markup]下添加以下内容(记得缩进) [markup.goldmark] [markup.goldmark.renderer] hardWraps = false unsafe = true xHTML = true 使用的\u003cimg src=\"\" width= /\u003e配合\u003ccenter\u003e;图片文件夹放置在static下。 为什么不使用shortcode,主要是没搞懂; 为什么不使用markdown语法，因为没法定义大小 ","date":"2021-05-04","objectID":"/programming/blog-hugoanddiary/:3:3","tags":["theme","hugo","blog"],"title":"Blog搭建的那点小事","uri":"/programming/blog-hugoanddiary/"},{"categories":"Blog","content":"博客中间宽度 位置：diary/assets/scss/journal.scss 内容：本来两边都是25%，调整两边的百分比就可以了 $side-container-width: 21%; $extra-container-width: 21%; ","date":"2021-05-04","objectID":"/programming/blog-hugoanddiary/:3:4","tags":["theme","hugo","blog"],"title":"Blog搭建的那点小事","uri":"/programming/blog-hugoanddiary/"},{"categories":"Blog","content":"主题有待完善 tags页面 目前情况：一个标签占一行。很浪费，不美观，翻阅点击很费劲。 希望改变：多个标签一行,如果有多篇文章提了这个标签，就让此标签变大加重。 图片浏览 目前情况：点击不了，没法放大，只图片浏览。 希望改变：加入可以点击浏览所有图片的功能。 代码 copy按钮，折叠功能 目录 没有一级标题不显示(强制展开，就不能折叠) 不会 自动折叠/展开 子标题 ","date":"2021-05-04","objectID":"/programming/blog-hugoanddiary/:3:5","tags":["theme","hugo","blog"],"title":"Blog搭建的那点小事","uri":"/programming/blog-hugoanddiary/"},{"categories":"Blog","content":"四、总结  总之，至少主题风格很对口味，可惜一些需求没有实现,但任何东西本身就没有完美之说,不是吗。 See you next time. ","date":"2021-05-04","objectID":"/programming/blog-hugoanddiary/:4:0","tags":["theme","hugo","blog"],"title":"Blog搭建的那点小事","uri":"/programming/blog-hugoanddiary/"},{"categories":"数码","content":" \" 我并没有什么方法,只是对于一件事情很长时间很热心地去考虑罢了。\" —— 牛顿 前言  其实在很久很久以前，就想要用 kindle 来看书，只是迫于种种原因而迟迟未动。例如这些： 它只是个看书的产品，没有其他额外的功能，我为什么不买个 ipad 呢; 它刷新的时候，还要闪几下，就很烦; 它操作起来和老年机一样慢，不能忍受; 它有点小贵，我为什么不把那几百块钱吃点好的呢。  我现在再次看来，也许这些都不是问题。我们追求的是什么东西？不过是纯粹的阅读体验罢了，多余的功能那才是多余吧。 开箱 ","date":"2021-01-01","objectID":"/life/ob-kindle/:0:0","tags":["kindle","paperwhite4"],"title":"2021年的第一次开箱-kindle","uri":"/life/ob-kindle/"},{"categories":"数码","content":"看官请 Fig1. 包装 Fig2. 还是包装🤣 Fig3. 本体 Fig4. 全家福 感想  拿到手中的那一刻，感觉好小啊，确实很小巧。背壳的手感是真的好，摸上去十分的舒服，整体很圆润。 虽然屏幕小了些，但是拿到手里很方便，190 多 g, 不至于手很难受。观感也挺舒服的，背光灯也是有的。还有防水啥的，这个我可不会边洗澡边它看书,来测试它的防水性。就像你买一台 iphone,他说有多牛的防水，结果如果你是去测防水中它 gg 了，Apple 这个伟大的公司可是不会给你免费维修的。 希望它能陪伴我，徜徉于书海之中。最近，知识的读书没少，但是精神的读书和人生的思考却逐渐少了。好了，此刻就让我再次捡起它吧。2021,你好呀！ ","date":"2021-01-01","objectID":"/life/ob-kindle/:0:1","tags":["kindle","paperwhite4"],"title":"2021年的第一次开箱-kindle","uri":"/life/ob-kindle/"},{"categories":null,"content":" 宇宙虽有其起源，却没有终结 无限 星球也有起源，却因其自身之力走向毁灭 有限 Contact: i@mail.shawncheung.com ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":" ","uri":"/about/"}]